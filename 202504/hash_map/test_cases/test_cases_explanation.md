# ハッシュマップのテストケース解説

## テストケースの設計思想

ハッシュマップの実装をテストするためには、様々な状況や条件下での動作を検証する必要があります。このドキュメントでは、各テストケースの目的と設計意図について詳しく説明します。

## テストケース一覧

### Case 1: 基本的なキー・バリュー操作

**目的**: 最も基本的なハッシュマップの機能をテストする

**操作内容**:
```json
[
    { "action": "put", "key": "apple", "value": 5 },
    { "action": "put", "key": "banana", "value": 8 },
    { "action": "put", "key": "orange", "value": 10 }
]
```

**期待される結果**:
```json
{ "apple": 5, "banana": 8, "orange": 10 }
```

**検証ポイント**:
- 基本的な挿入操作が正しく機能するか
- 異なるキーに対して値が正しく格納されるか
- 最終的なハッシュマップの状態が期待通りか

### Case 2: 基本操作（put、get、remove）

**目的**: ハッシュマップの3つの基本操作（put、get、remove）をすべて検証する

**操作内容**:
```json
[
    { "action": "put", "key": "apple", "value": 5 },
    { "action": "put", "key": "banana", "value": 8 },
    { "action": "put", "key": "orange", "value": 10 },
    { "action": "get", "key": "apple" },
    { "action": "get", "key": "banana" },
    { "action": "remove", "key": "orange" },
    { "action": "get", "key": "orange" }
]
```

**期待される結果**:
```json
{ "apple": 5, "banana": 8 }
```

**検証ポイント**:
- 値の挿入が正しく行われるか
- 挿入した値が正しく取得できるか
- キーと値のペアが正しく削除されるか
- 削除後にそのキーにアクセスすると何も返さないか

### Case 3: 既存キーの上書き

**目的**: 同じキーに対して異なる値を複数回設定した場合の動作を検証する

**操作内容**:
```json
[
    { "action": "put", "key": "apple", "value": 5 },
    { "action": "put", "key": "banana", "value": 8 },
    { "action": "put", "key": "apple", "value": 10 },
    { "action": "put", "key": "banana", "value": 15 },
    { "action": "put", "key": "cherry", "value": 20 }
]
```

**期待される結果**:
```json
{ "apple": 10, "banana": 15, "cherry": 20 }
```

**検証ポイント**:
- 既存のキーに新しい値を設定すると、古い値が上書きされるか
- キーの一意性が保持されるか
- 最終的に各キーに対して最新の値が格納されているか

### Case 4: エッジケース

**目的**: ハッシュマップの実装が様々な特殊なケースを適切に処理できるかを検証する

**操作内容**:
```json
[
    { "action": "get", "key": "nonexistent" },
    { "action": "remove", "key": "nonexistent" },
    { "action": "put", "key": "test", "value": 42 },
    { "action": "get", "key": "test" },
    { "action": "remove", "key": "test" },
    { "action": "get", "key": "test" },
    { "action": "put", "key": "", "value": 100 },
    { "action": "get", "key": "" }
]
```

**期待される結果**:
```json
{ "": 100 }
```

**検証ポイント**:
- 存在しないキーに対するget操作が適切に処理されるか
- 存在しないキーに対するremove操作が適切に処理されるか
- キーを追加した後の取得と削除が正しく機能するか
- 空文字列をキーとして使用できるか

### Case 5: 大きなデータセットでのパフォーマンステスト

**目的**: より多くのキー・バリューペアを扱い、ハッシュマップの拡張性とパフォーマンスをテストする

**操作内容**: 20個のキー・バリューペアの挿入、取得、削除、再挿入操作

**期待される結果**: 19個のキー・バリューペア（key14が削除され、key7が更新されている状態）

**検証ポイント**:
- 多数のエントリを効率的に処理できるか
- 特定のキーの削除と再追加が正しく処理されるか
- ハッシュマップが動的な変更を正しく処理できるか
- リサイズが必要な場合に適切に処理されるか

## テストケース設計の考慮点

1. **網羅性**: 基本操作、エッジケース、パフォーマンスなど、様々な側面をテスト
2. **段階的複雑さ**: 単純なケースから複雑なケースへと段階的にテスト
3. **再現性**: テスト結果が一貫して再現できるように設計
4. **検証容易性**: 期待される結果が明確で検証しやすいように設計

## テストケースの拡張案

現在のテストケースに加えて、以下のようなテストケースを追加することで、より包括的なテストが可能になります：

1. **大量データテスト**: 数千〜数万のエントリを扱うテスト
2. **ランダムアクセスパターン**: ランダムな順序での挿入、取得、削除操作
3. **特殊文字テスト**: Unicode文字や特殊記号をキーとして使用するテスト
4. **長いキーテスト**: 非常に長い文字列をキーとして使用するテスト
5. **衝突テスト**: 意図的に衝突を発生させるキーを使用するテスト
